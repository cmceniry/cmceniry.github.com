<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: SysAdmin | CorgaLabs Blog]]></title>
  <link href="http://cmceniry.github.com/blog/categories/sysadmin/atom.xml" rel="self"/>
  <link href="http://cmceniry.github.com/"/>
  <updated>2012-08-14T00:19:19-07:00</updated>
  <id>http://cmceniry.github.com/</id>
  <author>
    <name><![CDATA[Chris McEniry]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SOO: Pids over People]]></title>
    <link href="http://cmceniry.github.com/blog/2012/03/31/soo-pids-over-people/"/>
    <updated>2012-03-31T06:24:00-07:00</updated>
    <id>http://cmceniry.github.com/blog/2012/03/31/soo-pids-over-people</id>
    <content type="html"><![CDATA[<p>tl;dr</p>

<p>I come here not to <em>bury</em> NoOps, but to <em>praise</em> it.</p>

<ol>
<li>There are two extremes when it comes to service management: small
tight team doing Dev and Ops roles, and separate teams for Dev and
Ops. Both of these will exist at various times for various scope.
In the middle is confusion.</li>
<li>As Ops teams, we can enable Dev teams by providing them ways to
enable themselves. Let's figure out how to provide XaaS
more. Infrastructure, Config/Deploy, Monitoring, etc. XaaS doesn't
have to mean an API but it does mean a very predictable response.</li>
<li>As engineering(Dev+Ops) groups, we all like the idea of putting
together a project using a small/dedicated team with no
externalities. XaaS helps this to the degree that some items are
decoupled, but there's a level of knowledge that XaaS can't convey,
so let's figure out how to make that happen.</li>
<li>No size fits all, so you have to constantly evaluate and bounce
back and forth on a service by service basis, and figure out how to
fill in gaps while you're transitioning from one to the other.</li>
</ol>


<h3>Disclaimer</h3>

<p>Bias alert: I'm an Op, and there is a bit of frustration here (it
comes out as sarcasm). I like to think I'm opened minded but I am
being a bit irrational here.  so tread forward with that in mind. My
goal is to improve not justify myself.</p>

<p>And to be fair, this doesn't just apply to Dev and Ops. It can also
apply to Sec, QA, Data Analysis, etc. It's just a matter of how
coupled some of these are. DevOps is just on my radar, so that's my
focus.</p>

<p>This is my first attempt at a longer form (almost 3x my previous
longest post). I'm attempting to make it not sound like a load of
stream of consciousness dribble, so... be gentle.</p>

<h3>References</h3>

<p>There's been a lot of talk about DevOps and NoOps over the past
week. I can't say how it started, so I'll pick it up with
<a href="http://perfcap.blogspot.com/2012/03/ops-devops-and-noops-at-netflix.html">Cockcroft</a>.
It's a nice piece on how Netflix does their internal product
development (lots of automation and relying on services instead of
groups - <em>remember this part</em>). There's some commentary over the
terms. I probably have the same reaction to it as
<a href="https://gist.github.com/2140086">Allspaw</a> does, but similar
<a href="http://blog.ingineering.it/post/19383804543/devops-vs-noops-misses-the-point">to</a>
<a href="http://www.edwardcapriolo.com/roller/edwardcapriolo/entry/noops_devops_yesdilusional_no_it">others</a>,
I don't think operational aspects are going to go away. And Cockcroft
even follows up with "I think we agree to call it PaaS," so it's not
so much about the terms.</p>

<p>To spell it out, there's 2 threads here:</p>

<ol>
<li>There is a move to use services (i.e. APIs, XaaS)</li>
<li>You can't get rid of operational concerns, but you may have to
focus the resources differently.</li>
</ol>


<p>I don't think people will argue with the later, so I want to know what
the former means. I'm starting with how I saw it come about.</p>

<h3>The DevOps/Dev Ops Cycle</h3>

<p>I think a lot of organizations follow a similar pattern:</p>

<p>Small team develops a platform and people wear the dev and ops
hats. Platform grows and gets too big for a small team to manage. The
team is spending too much time fire fighting and in operational
aspects, so they specialize. Eventually, you end up with a Dev side
and Ops side which are (or have grown to be) completely different
people. The smart (and humble) ones feel like it's too disjointed and
don't feel like they can move the organization (too big, too much
inertia), so they splinter off on a skunksworks project with a small
team. The smart but not humble ones just see the other side as a bunch
of oafs, so they splinter off on a skunksworks project with a small
team.</p>

<p>Repeat ad nasuem.</p>

<p>The pendulum swings back and forth. Is this the way it has to be?</p>

<p>Going back to Allspaw:</p>

<pre><code>Etsy has an Operations org, people with "Operations" in their
title, and yet don't have a culture of red tape like you
describe. The premise you're implying doesn't exist here (that Ops
are grumpy people that say no all the time and are a source of
frustration and holdups) and I'm willing to bet it's the same in
other companies.
</code></pre>

<p>I'm probably not as optimistic as I think Allspaw is about the number
of companies, but there certainly are some. He continues:</p>

<pre><code>My definition of Ops involves the responsibility to make it safe
to make whatever change to production is necessary, at the rate
that it is necessary for the business to evolve.
</code></pre>

<p>There's a bit of paternalism here, but I will conceed that for
recognizing that we're enabling for a goal here. That goal is one that
allows anyone who needs to to make changes (i.e. contribute) to
production while at the same time taking out precautions against
issues that may crop up due to those changes.</p>

<p>Alas, I think some devs just don't see this and instead have to deal
with Ops groups that can't respond to their needs. It's not
necessarily a problem with the Ops team, but that the Dev sees the Ops
as a roadblock. Yea, sometimes the Ops teams is just lacking. Other
times, it's overwhelmed as it has to respond to everyone else and
can't focus on its needs looking forward. And I have to mention those
Devs that just don't give a damn and are going to do it their way come
hell or high water.</p>

<p>So, they turn the cycle around again and toss the baby (operational
experience) with the bath water (unresponsive ops team). They go
looking for ops sides (XaaS) that can respond - even if it is in a
limited way, and not a way that is tailored to them. They adapt their
processes to work within the framework that at least gives them some
predictability and how they want it.</p>

<h3>#NoPeople</h3>

<p>(Apologies to Cockcroft here. I've respected him since his
VirtualAdrian days but this may not being completely fair to him.)</p>

<p>Cockcroft's article is littered with this pattern:</p>

<pre><code>Individual Cassandra clusters are automatically created by Priam,
and it's trivial for a developer to create their own cluster of
any size without assistance (NoOps again).
</code></pre>

<p>"Without assistance" - no people.</p>

<pre><code>...we have hundreds of developers using NoOps to get their code
and datastores deployed in our PaaS and to get notified directly
when something goes wrong.
</code></pre>

<p>"Developers... get notified directly" - no people.</p>

<pre><code>...no need for the developers to interact with ops people to get
things done.
</code></pre>

<p>"No need... to interact" - no people.</p>

<p>I'm not sure if #NoOps is the right hash or #NoPeople is. Yes, the dev
is involved but not in all cases:</p>

<pre><code>We have built tooling that removes many of the operations tasks
completely from the developer.
</code></pre>

<p>I have to read from that that the real goal is to completely remove
people from the picture. That's not necessarily a bad thing. Good
automation has always been a goal of any real (Ops?) organization
worth its salt, even with the ever present
worry-about-automating-yourself-out-of-a-job thought process. But this
isn't strictly about automation. It's about removing roadblocks or
unpredictables out of the equation. It's about taking <em>other</em> people
out of the picture. Let's call-a-spade-a-spade.</p>

<p>&lt;pithydiversion&gt; Let me flip it around. Here's my next user
story: As an Op, I would like an automation button for a feature
change instead of having to explain it to a developer, and then get it
into their backlog, get it prioritized, get it implemented, tested,
and then eventually released to me to be rolled out (with
documentation?). I would be claiming ownership over #NoDev, but I
think @DEVOPS_BORAT has beaten me to <a href="https://twitter.com/#!/DEVOPS_BORAT/status/108335303382663169">that</a>.
&lt;/pithydiversion&gt;</p>

<h3>SOO or OaaS or PoP</h3>

<p>So, we keep replacing people with some service or API, and lead to the
logical conclusion is that people no longer interact with each other;
instead, we interact with whatever service or API that someone else
has offered. I'm not sure if this is:</p>

<ul>
<li>Service Oriented Organization</li>
<li>Organization as a Service</li>
<li>Processes(pids) over People</li>
</ul>


<p>To be fair, I have to say that I do appreciate this approach from an
actual service offering. I have to give a nod to
<a href="https://plus.google.com/112678702228711889851/posts/eVeouesvaVX">Yegge</a>
here. It shouldn't surprise us that we're doing the same thing with
the organization as we are with our service components.</p>

<p>The ultimate form of the Dev/Ops divide is using a separate service
just as you would use an API. Of course, that's only a divide around
one factor (infrastructure versus platform, platform vs app, etc). As
has been said before "AWS becomes your Ops team."</p>

<p>This is efficient, right? Maybe, but that's not what's getting to
me. Why does it bother me? There's two reasons.</p>

<h3>The Agile Manifesto Doublestandard</h3>

<p>As an Op, I feel like there's a double standard here. For 10 years,
we've been hearing how Agile was supposed to fix the problems between
Product Management and the Development sides of the organization. The
key has been interaction and adaptability because predictability has
always been lacking.</p>

<pre><code>People over Process.
</code></pre>

<p>The downside has been that since you're going for these short
interations, any externality can totally derail your sprint.</p>

<p>So, when interacting with an under-responsive Ops organization, the
Devs just see them as a roadblock, not as something to work with. (I'm
projecting:)</p>

<pre><code>Screw people over process. We want process over people if process
is more predictable.
</code></pre>

<h3>Masters of our own Destiny</h3>

<p>I used to think that it really came down to control. Everyone wants to
be in control. Ops want to be in control of production. Dev was to be
in control of the service. That's not the real case (well, it is in
some highly disfunctional people).</p>

<p>&lt;rant&gt;I believe that I want to work in an organization that is full of
people respecting each other. Maybe I'm being naive - it's a
dog-eat-dog business world.</p>

<p>Well, if that's the case, <a href="http://www.youtube.com/watch?v=35TbGjt-weA">fuck that</a>.</p>

<p>Since I'm not going to conceed that quickly, I'm going to stick with
my naivety and plow forward.&lt;/rant&gt;</p>

<p>I think it's more about being MoooDy - Masters of our own Destiny. I
think we're climbing Mazlow's pyramid to self-actualization, even if
we don't realize or acknowledge it.</p>

<p>The key from that is being able to work together better, and part of
that is for the Ops side to deliver in a predictable manner (be it
manually, or automatically) to help Devs reach the top of that
pyramid.</p>

<h3>People are not pids</h3>

<p>The second reason is as simple the fact that people are not pids. A
service is ideally (warning: SOA and Unix mentality here) meant to do
one thing and do it well. A person on the other hand usually
doesn't. In fact, if there's a person who does, it's not that way
for long. He quickly becomes obsolete and the rest of us move on.</p>

<p>Author Unknown (though I heard it from Harvey Mackay):</p>

<pre><code>Amateurs practice till they get it right. Professionals practice
until they can't get it wrong.
</code></pre>

<p>You can't ditch people with Ops experience without taking the
hit. You can recover from that, but it's still a hit. You want to
preserve the focus and practice.</p>

<p>There's only so much that services at this time can do. They have to
completely evolve. And while they're evolving, you want good people to
be able to fill in the gaps.</p>

<h3>The in-house trap</h3>

<p>I think there's a case that demonstrates the above for the
process.</p>

<p>Consider that an in-house infrastructure team does its job well. It's
listened to development, and provides a beautiful IaaS interface and a
beautiful Deployment-aaS interface. If the process doesn't change (for
even something as insignificant as if the developer <em>doesn't like
it</em>), it's started to be seen as unresponsive just as Ops teams in the
past have been seen. Development's immediately found a reason for
going with some other service (i.e. some other "Ops" team). Another
skunkworks project is started and we spin the cycle once again.</p>

<p>This turns into a catch-22 if the service couldn't change because it
was servering Development on the whole but there's even one dev
breaking from the herd. Given that organizational issues run deeper
than any Dev/Ops devide, what are the chances of that?</p>

<h3>Coupling trap</h3>

<p>SOA/XaaS works well when there's a loosely decoupled aspect to
everything. Once that goes out the window, the level of complexity
goes off the rails.</p>

<p>Likewise, XaaS works well when it's loosely decoupled.</p>

<p>For example, consider an PaaS/IaaS. A running application is heavily
dependent upon the system it runs on. Libraries have to be installed,
and they need to match version (and get updated hand-in-hand). Kernel
APIs have to match up, or at least behave similarily. It's hard to
decouple apps from the underlying system. So, creating a PaaS there
(or IaaS if you want to see it that way) can run into some edge cases
that make it very tricky (repeat the in-house trap).</p>

<h3>#DevOps</h3>

<p>So, there are cases when XaaS doesn't cut it. What do you do? Mix the
roles in with who's doing them, which leads me to DevOps.</p>

<p>There's a bunch of commentary on it, so I won't rehash that. Suffice
to say that people have to handle both dev and ops
responsibilities. This can be either in the Dev part of the
organization (e.g. responsible for running a customer facing service),
or it can be in the Ops part of the organization (e.g. responsible for
running an internal customer facing service).</p>

<p>Well, this can have it's own problems. Consider compliance. There are
compliance standards that require a separation of Ops from Dev. I have
no idea how to approach this one, but any devops move or adding
self-service seems to fly against this. But it remains a piece that
has to be accounted for. If someone can explain to me how any of this
can be PCI approved without the separation of duties, I'd be eternally
grateful...</p>

<p>You also have to consider the scaling cases. Services grow, teams
grows, and as we approach communication issues, we have to fragment
them. Sometimes you fragment the service; sometimes you fragment the
teams.</p>

<h3>Service Catalog and Service Lifecycle Management</h3>

<p>So, when you're back to Dev and Ops and don't have an XaaS setup yet?</p>

<p>ITIL (&lt;groan&gt; - hear me out) has an idea of a <a href="http://www.knowledgetransfer.net/dictionary/ITIL/en/Service_Catalog.htm">Service Catalog</a>.</p>

<p>It's basically a menu of what the IT organization provides you. It's
not specific about whether this be provided by people or by an
automated process or by self-service. The key is to define it in
business terms and include costs and SLAs.</p>

<p>In addition, there's the Service Lifecycle Management. It basically
handles how new service offerings roll in, or more useful to this
discussion, how service offerings evolve. This provides the
adaptation that is required. As the service matures, it natually moves
out from being a human led service and into a XaaS led service.</p>

<p>There's something to be said for Lean and just in time service
delivery, but I'm just not articulate enough to incorporate that in
yet.</p>

<p>The key here is that it doesn't have to be an API. Though, I do have
to conceed, an API usually has a very well defined (though maybe not
documented) service catalog. Can't really beat that.</p>

<p>And yes, I'm bringing ITIL in here. Whether you agree with the full
stack or not, there are some useful parts of it.</p>

<h3>The spectrum</h3>

<p>On one side you have small tight teams. On the other side, you have
separate and efficient Devs and Ops teams (with a XaaS being a valid
form there). In the middle is... muck. It's where you don't want to
be. You want to go one way or the other. Both sides can exist at the
same time, but they need to be distinctively on the sides, not
averaging in the middle. How do you get there?</p>

<p>To get to DevOps, you move your teams so that you're embedding
functionality around various services. This means pulling people out
of their traditional comfort zones and putting them into something
that rounds them out.</p>

<p>To get to Dev and Ops, you have to put together a good service
catalog. You can either spell it out with people, or by figuring out
how to create some sort of XaaS offering. Ironically (or not?), that
XaaS offering's team will probably start off looking like a DevOps
team (hence why both sides of the spectrum can exist at once).</p>

<p>In all of these cases, we're talking about real people and these
decisions have consequences. We have to remember that and go back to
the Agile motto of "People over Process." So, above all you have to
have honest communication as what's needed, what's missing, and what's
open to be experimented with.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANCL: Application Network Communication Language]]></title>
    <link href="http://cmceniry.github.com/blog/2012/03/26/ancl-application-network-communication-language/"/>
    <updated>2012-03-26T20:16:00-07:00</updated>
    <id>http://cmceniry.github.com/blog/2012/03/26/ancl-application-network-communication-language</id>
    <content type="html"><![CDATA[<p>I'm starting a new project aimed at handling firewall policies in a
sane way. Well, it's not so much the firewall policies themselves, as
it about how we think about the firewall policies, or more precisely,
about how we think about the application policies themselves.</p>

<p>All firewall configurations that I've been part of have come about in
a specific pattern:</p>

<ol>
<li>Someone writes an application, and puts together some documentation
that, if we're lucky, includes a visio of how the application
talks. Most of the time, it's something closer to a "open these ports
on your firewall to make this happen."</li>
<li>A sysadmin/app engineer/gwmth(guy who makes things happen - some
future post) looks over the documentation and identifies specific
hosts (IPs really) based on where the app components are running. He
puts together a ticket asking for specific ports to be open for
specific IPs or ranges. If you're lucky (I'll admit, I've been that
lazy admin), the admin puts together a visio of how it is all laid
out.</li>
<li>A netadmin takes the rules from the sys/app admin, tries to match
them up to existing rules or network ranges and adds them to the
firewall. If it's not a stateful device, it's worse than that as
you're limited by the language.</li>
</ol>


<p>So, we've got a little game of operator going on here. On top of that,
usually the only permanent records of the change show up in two
places: any ticketing system, and the firewall itself. This means that
to try to figure out what happened, you have to go sort through
tickets or reverse engineer it from the firewall itself.</p>

<p>If you've ever had to deal with this, you end up having to reverse
engineer it all the time.</p>

<p><strong>This doesn't work.</strong></p>

<p>There's now <a href="http://www.redsealnetworks.com/">tools</a> that will help
you with this, be more efficient at it. They look at all of the rules
and you can go back and check to see what's approved for what. But the
modelling is still done on a "this IP has access via this port to this
other IP, and this collection of IPs/ports are this model." But it's
still approaching it the wrong way - and if you're more efficient at
doing the wrong thing, you're just doing it wronger.</p>

<p>These tools do other things, but from an application perspective,
they're very late in the game. So, late that it feels like we're doing
network management backwards. I think we gotta go back to the
beginning. Instead of focusing on the network and building rules from
there, I want to start with the application and derive the rules from
there.</p>

<p>And yes, before we go there, documentation is good. I'm not trying to
give people a pass on the documentation. I'm trying to find a way that
makes it easier to document. So, keep that in mind.</p>

<p>Imagine that when you write an application, you can also easily
identify what network communication is needed relative to the
components for you application. For example, look at a simple LAMP
application. It fundamentally, has 3 components:</p>

<ol>
<li>the Database,</li>
<li>the Web Server, and</li>
<li>the web site consumers.</li>
</ol>


<p>And we can readily identify what access is needed:</p>

<ol>
<li>The <strong>Web Server</strong> needs access to the <strong>Database</strong> on port
<strong>3306</strong>.</li>
<li><strong>Web site consumer</strong>s need access to the <strong>Web Server</strong> on port
<strong>80</strong>.</li>
</ol>


<p>It's fundamentally "X needs access to Y on port P" or if you want to
move it around "X is allowed on port P to Y" or "X is allowed P to Y."
If you've done any access control before, you'll notice the same
pattern of Actor(X), Resource(Y), and Permission(P).</p>

<p>I think there's something about this that can be done
<a href="http://en.wikipedia.org/wiki/Security_Assertion_Markup_Language">SAML</a>,
but its focus is on the individual's identity and access
control. Maybe there's something I'm missing, but if I am, <a href="https://www.google.com/search?q=don't+understand+saml">I don't
think I'm in the minority</a>.</p>

<p>So, we have a general form for recording the policy. There's also the
other key take away from this one in that we're not dealing with
IPs. Nowhere above is an IP listed. We're talking about components
(Actors and Resources). This could take the form of:</p>

<pre><code>{'MyWebSiteModel':
  [
    'WebServer': 'DB:3306/tcp',
    'WebSiteUser': 'WebServer:80/tcp'
  ]
}
</code></pre>

<p>This is just the general description. It's still not very useful. To
do that we have to instantiate it - basically, assign hosts/IPs to
each of the components:</p>

<pre><code>{'MyWebSiteInstance':
  'Model': 'MyWebSiteModel',
  'Components': {
    'DB': ['2.2.2.2'],
    'WebServer': ['1.1.1.1', 'web2.mydomain.com'],
    'WebSiteUser': ['0.0.0.0']
  }
}
</code></pre>

<p>Based on all of that information, you can form the rules that would be
needed to fit any firewall.</p>

<p>How does this address my initial problem? It comes down to fitting the
abstraction model to the handoff points:</p>

<ol>
<li>Application Developer: Generates the components and communication
patterns.</li>
<li>Application Administrator: Instantiates and assigns specific IPs or
hosts to each of the components.</li>
<li>Network Administrator: Gets a concise description to work from. If
the right amounnt of automation is applied, I might be marginalizing
the network admin for this task (that's not completely true - there's
plenty of sites that have enough device complexity that no simple
model will be immediately applicable - but it could still be used as a
starting point)..</li>
</ol>


<p>The model I used above is overtly simple. I already have questions
around RPCs, dynamic ranges, encapsulated protocols (* over http,
anyone?). I'm only starting the discussion here and dealing with the
minimal accomplishable step. It's something to build on.</p>

<p>Now for the practical hand waving. The follow up pieces to this are
the tools to make it useful. We still need:</p>

<ul>
<li>A tool for recording this. This could be done via the above forms,
but it'd be nice to have it wrapped up in a bow. This is doubly
desired when we have to consider how all of the policies are
instantiated with the specific host information.</li>
<li>A tool for visualizing. It'd take in the general descriptions, and
show a pretty display for it.</li>
<li>A tool for converting the models to rules. It would take in the
general descriptions, the specific host information for each
instantiation, and then outputs some for iptables, pf, acls,
firewall policies, etc. Yeah, some magic here.</li>
</ul>


<p>So, first things being first, my <a href="http://github.com/cmceniry/ancl">next project</a>
is something for tracking.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language matters: Nitpik with Chef]]></title>
    <link href="http://cmceniry.github.com/blog/2012/02/05/language-matters-nitpik-with-chef/"/>
    <updated>2012-02-05T23:14:00-08:00</updated>
    <id>http://cmceniry.github.com/blog/2012/02/05/language-matters-nitpik-with-chef</id>
    <content type="html"><![CDATA[<p>For a while now, Chef has bothered me. Some of it I can blame on the
server setup (pull/push and exposure of general manifests), but
there's been something that's been bothering that I hadn't been able
to put my finger on... until now.</p>

<p>First, I'm going to come out and admit my bias to a declarative model
over an imperative model. I won't go into why. Burgess does a much
better job <a href="http://cfengine.com/markburgess/blog_order.html">describing this</a>.</p>

<p>My issue with Chef comes down to one word: action.</p>

<pre><code>package "ntp" do
  action :install
end
</code></pre>

<p>Now, to be fair, this is a very declarative description. If you dig
into what it's doing, you'll find that it's interrogating the system
and only installing the package if it needs to, or alternatively,
it'll make sure that the package exists. If that's the case, it's not
"install"ing every time, it's making sure it's
"install"ed. "Install"ing is a verb (it's saying "action"), but
"Install"ed is a noun (state).</p>

<p>Why does this matter? Let's go back to cfengine:</p>

<pre><code>commands:
  "yum install -y ntp"
    ifvarclass =&gt; "!ntp_installed"
</code></pre>

<p>Now, we're further down the slope. This is a command/verb/action -
there's now way around that. We've detached the descriptive goal of
what we want from how we've written. We have to know that our
convention for an installed package is to use that command structure,
and to make sure there's a class that checks for if ntp is installed
or not. The var is in the check, not in the overall description.</p>

<p>So, why is Puppet better?</p>

<pre><code>package { "ntp":
  ensure =&gt; present
}
</code></pre>

<p>There's no confusion around this one. It's clearly saying make sure
this package is present/installed. The magic of how that happens is in
the underlying resource abstraction layer, which is cool in and of
itself, but it's real win is that it allows you to continue thinking
in a declarative way, not in an imperative way. There's no mental
flipping back and forth.</p>

<p>Ok - so why does <em>that</em> matter?</p>

<p><a href="http://en.wikipedia.org/wiki/Linguistic_relativity">Language matters</a>.
Language influences the way you conceptualize a problem, plain and
simple. The BDD guys hark on this as well. I think for sysadmining
roles to move forward, we need to think in a declarative way. Yes,
there are times for an imperative method, but not in system
descriptions.</p>

<p>So, it's a nitpik, but it's one that can have far reaching impact.</p>

<p>And yes, I know you can do execs in Puppet, so you can shoot yourself
in the foot, but you'll have less misfires with Puppet than with other
tools because of the way it makes you think.</p>
]]></content>
  </entry>
  
</feed>
