<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cloud | CorgaLabs Blog]]></title>
  <link href="http://cmceniry.github.com/blog/categories/cloud/atom.xml" rel="self"/>
  <link href="http://cmceniry.github.com/"/>
  <updated>2014-01-26T22:41:41-08:00</updated>
  <id>http://cmceniry.github.com/</id>
  <author>
    <name><![CDATA[Chris McEniry]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[More than just Pets and Cattle]]></title>
    <link href="http://cmceniry.github.com/blog/2014/01/11/more-than-just-pets-and-cattle/"/>
    <updated>2014-01-11T21:51:00-08:00</updated>
    <id>http://cmceniry.github.com/blog/2014/01/11/more-than-just-pets-and-cattle</id>
    <content type="html"><![CDATA[<p>wIt's been said many times many ways that cloud) servers should be
treated like cattle, and not like pets. Looks like the first reference
is
<a href="http://www.slideshare.net/randybias/architectures-for-open-and-scalable-clouds">Bias</a>,
but there are quite a few others:
<a href="http://www.computerweekly.com/blogs/cwdn/2013/04/treat-cloud-servers-like-cattle-not-puppies.html">here</a>
<a href="http://www.gregarnette.com/blog/2012/05/cloud-servers-are-not-our-pets/">here</a>
<a href="http://www.theregister.co.uk/2013/03/18/servers_pets_or_cattle_cern/">here</a>
<a href="http://www.dameware.com/cmdprompt/are-your-servers-pets-or-cattle-.aspx">here</a>
just the top ones on a google search. The main idea being that we had
this tendency when the servers were fewer yet more longitudinal to
treat them delicately: putting care and feeding into each of them; now
that we (can) have large amounts of short lived instances, we can't be
bothered with the same care.</p>

<p>That's a completely valid way of thinking (it's a great <em>place</em> to
be), so I'm curious as to where its limits are. In some ways, looking
at just servers that way is looking at a point in time and
capabilities and thought.</p>

<p>We've all had pet files. Remember that hand crafted config file that
you spent days of your life tweaking to get it just right? Maybe it
was specific to that host. At some point, you groomed it enough that
it became a golden file for your entire environment and you could copy
it and push it out to all of the other servers. Then you pushed it out
using some higher level config management system. Then you moved up
some semantic level and the file itself got abstracted into specific
resources, and those were composited and pushed out. So, files started
as pets, and by realizing that the file was only a model of something
that we actually cared about, they moved to cattle.</p>

<p>Really, pets are pets because you've become attached to them - you
can't clone them, and it hurts to lose them. Cattle is cattle because
it's easy to get another and it's not a big deal if you lose
it. There's a lot of different specific means to achieve these, but
it's these two fundamental classes of properties that enable this
thinking:</p>

<p>1.) It's easy to copy, and
2.) It's easy to handle losing it (enter whatever you want to say
about antifrigilness here).</p>

<p>But thinking about files and servers is so the 2000-noughts. What are
our pets now?</p>

<p>Moving up from the server, is the cluster. Are clusters now the new
pets? or can we treat them as cattle as well? Given sufficiently large
IaaS services and strong configuration management systems and lots of
variable substitution (well, probably more like locally realized
global patterns), it's actually fairly easy to fulfill property #1
above - copying. As for #2, if you have sufficient global load
balancing of any form (DNS, anycast, etc), you can easily route
traffic to working clusters, or more precisely, away from failing
(lost) clusters.</p>

<p>So, pulling further out, our clusters collapse into a service. Is that
our new pet? With even more config and *aaS and some client service
discovery (aka any sufficiently advanced delivery model), you can
certainly copy it. Though, if you lose your source code, it would
definitely take a bit to reproduce the service (get all those coders
together again, etc). What about losing it? Well, if you are a single
feature service inside of a larger service, you might be able to be
disabled, so you can lose it. But what about that larger service? I
think for most businesses, you can't just lose it.</p>

<p>So, that's your pet.</p>

<p>Maybe.</p>

<p>(One could examine businesses and business models and plans and use
the same comparisons, but I think this first point - what makes
something pet versus cattle across various object domains is copying
and dealing with lose - is done well enough, so my second point...).</p>

<p>There's another way to slice (heh) this metaphor: milk. Not all cattle
is used for steak. Some cattle is used to produce a product, bulked up
again, then produce more of the same product. That cycle time might be
a little too short, so the metaphor might make a little more sense by
using different livestock - sheep. Some sheep are raise for mutton,
some sheep are raise for wool (and yes, you can do both, but
still). For the wool sheep, after the wool is reaped each year, you
have to let it grow out again before you can reap it again, all the
while caring for the sheep. The sheep itself stays around, but you
continue to reuse it.</p>

<p>That being said, you can use other sheep for the same purpose because
lots of wool is the same; and sheep have their own way to easily copy
each other well enough.</p>

<p>But you still don't really want to lose a sheep. You still gotta deal
with it going away and getting the replacement there. The same really
applies to larger services (or businesses) - maybe you can copy it,
but you really don't want to deal with it going away.</p>

<p>So, my second point is really that there's a third category between
pets (hard to copy, hard to deal with loss) and (steak) cattle (easy
to copy, easy to deal with loss), and that's of the milk cattle (easy
to copy, but still hard to deal with lose). This last category by its
very nature persists and is modified, rather than being destroyed and
rebuilt each time. All of those things that we had to think about for
when we wanted to change our pets still apply. Maybe it's not to
servers, but the lessons learned are still valuable.</p>

<p>And lastly, not everyone is <em>there</em>. And not everyone who is <em>there</em>
is <em>there</em> for everything that they do (there's probably a mix of
services made of cattle and services made of pets in a lot of
organizations). So don't feel bad. Just figure out which one it should
be and work to improve.</p>

<p>PS Interesting enough, if we do the combinations of the above, there's
the last class: a service which is hard to copy, but you can deal with
failure. I'm not really sure what that looks like, so I'm going to
leave it as an exercise for the reader. I'd be curious if anyone comes
up with something interesting. Contact me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A tale of two PaaSes]]></title>
    <link href="http://cmceniry.github.com/blog/2013/03/13/a-tale-of-two-paases/"/>
    <updated>2013-03-13T20:38:00-07:00</updated>
    <id>http://cmceniry.github.com/blog/2013/03/13/a-tale-of-two-paases</id>
    <content type="html"><![CDATA[<p>I spend a good amount of time trying to figure out if my operational
team can do much to make the general engineering efforts more
productive. We've followed the usual turns around self-service IaaS
and the like, and we're now exploring the next level of
Platforms-as-a-Service. In exploring the options, I'm seeing two large
patterns.</p>

<p>On one hand, there are the "middleware centric and injection based"
PaaS models. These are the ones where the developer picks a
development middleware (Java Servlet, PHP, Node, Rails, etc), and adds
other parts in. As if by an after thought, a static file service is
added, or maybe a data persistance (i.e. database) service is
added. On a implementation level, these usually involve allocating
some compute and storage resource (e.g. a VM), installing the
middleware container, doing a baseline install of the add-ons, and
starting them all up inside that VM. There are some other
configuration items such as pointing it at some version control
repository, but also the developer is able to login onto the VM via
shell.</p>

<p>On another hand, there's a "service focused" PaaS model. This feels
like the lesser named PaaS, though it probably has a larger install
because this is the model that AWS largely is. In this case, the
developer picks different service components (e.g. DB, cache,
messaging bus, etc) and composites them a bit more
independently. Underneath the control layer, each of the component
providers can implement their services in different ways - using
different VMs, processes, or internal containers (e.g. DB schemas w/
authnz) - based on what makes sense for that provider. There's more
work for the developer here as they have to compose services across
different providers, and the developer doesn't have direct access to
the underlying system, but in exchange, might have better options.</p>

<p>From an implementor's perspective, I think the service focused model
is easier to maintain. This may not necessarily be the right reason to
go down that route, but when it comes to delivery, that matters a
lot. It's also a bit more transportable - at this point in the
industry's lifecycle, it'd be easier to migrate from one IaaS or
traditional Infrastructure to another. It's also easier to extend this
model to other (traditional?) services such as monitoring. You can see
this in the industry - there's many different service providers
focusing on a narrow niche offering around one specific service, but
fewer middleware centric vendors and even those that exist tend to
also include some service based model for the add-ons.</p>

<p>As I said, most of the traditional services called PaaS are the
form. So, what makes the application middleware so much different than
a data store? or a caching layer? Fundamentally, you have some level
of "service" which you want to present a clean interface to. This is
true for the database as well as for a java servlet container, yet
somehow we treat them a little differently in our heads. The only
reason I can imagine is that is where time is spent. As a developer, I
spend most of my time in the code, so that's where my mind goes. But
while I run it, I want to have a better idea of how it fits in with
the other component services.</p>

<p>I think the vote is still out on which way has better long term
viability. And it may never be decided on. It may just be a matter of
preference.</p>

<p>Maybe PaaS isn't the right term for this second model. These are more
Services-as-a-Service, which seems likely to be a great way to confuse
people. Mmaybe they're more along the lines of Infrastructure, and are
just a different take on that. I'll admit, I'm not sure what the right
way to refer to them is, but I believe that the use case that they
present is more than just an implementor's fancy. It's a valid use
case based on how developers are expecting to work with it.</p>
]]></content>
  </entry>
  
</feed>
